#Project Title: Central Sands Nitrate Correlation - Romano Database and Land Use
#Project Description: evaluates the correlation between the nitrate levels from the romano database, and land use

#TODO
#t02 - look at changing function outputs to just add to the same data frame, rather than making a bunch of data frames
#t03 - this real slow. run profvis to check slowsteps (it's likely my for loops). Also see i t02 would help
#t04 - 

# -------------------Code begins here -----------------------

# ----0 Install Packages and Libraries----
#install.packages('sf')
#install.packages('ggplot2')
#install.packages('raster')
#install.packages('dplyr')
#install.packages('devtools')
#install.packages('profvis')

library(sf)
library(ggplot2)
library(raster)
library(dplyr)
library(tidyr)
#library(devtools)
#library(profvis)

source("U:/Trey Coury/Central Sands Nitrate/Central Sands Nitrate Estimator.R")

# ----1 Define Functions----
#' Read in shapefiles for our cells containing nitrate data
#' Taken from the Romano Database
#' @returns a dataframe of polygon shapefiles with Nitrate information
getNitrateCells <- function() {
  nitrateCells <- st_read(dsn = "U:/Trey Coury/DS002-dataset01/CSGCC_Nitrate_Neonicotinoids.gdb", layer = "Nitrate_stats_per_section_Non_PWS_2017_2022")
  nitrateCells <- st_transform(nitrateCells, crs = 3070)
  nitrateCells <- nitrateCells %>%
    select(PLSS, MEAN_Nitrate_mg_L_0, MEDIAN_Nitrate_mg_L_0, Shape_Length, Shape_Area, Shape)
  return(nitrateCells)
}

#' Given a set of polygons and a set of lines, finds the intersections
#' @param nitrateCells a data frame of polygons with nitrate data
#' @param allModpathFlowlines a data frame of lines
#' @returns the nitrateCells data frame with an additional column containing the flowlines that intersect it
getFlowLinesInNitrateCell <- function(nitrateCells, allModpathFlowlines) {
  intersections <- st_intersects(nitrateCells, allModpathFlowlines)
  nitrateCells$IntersectingFlowlines <- intersections
  return(nitrateCells)
}

#' prints dots to screen while looping
#' For loops take a while in R. This function is to print an output to the screen every once and a while so i know nothing has crashed
#' it prints a dot every 100 iterations, and a number ever thousand iterations
#' @param dotCount a counter variable to keep track of how many times we've gone through our loop
#' @returns a counter to be passed back in to the function
scrDots <- function(dotCount) {
  if ((dotCount %% 1000) == 0 ) {
    cat(dotCount %/% 1000)
  }
  else if ((dotCount %% 100) == 0) {
    cat(".")
  }
  dotCount <- (dotCount + 1)
  return(dotCount)
}

#' Get information about the contributing points for our nitrate cells
#' @param nitrateCells a data from of polygons with nitrate data
#' @param timeFrameOfInterest a time in years
#' @param allModpatFlowlines a data frame of flowlines, generated by MODPATH
#' @param allModpathStartingPoints a data frame of starting points for the flowlines, generated by MODPATH
getContributingPointsInfoForNitrateCells <- function(nitrateCells, timeFrameOfInterest, allModpathFlowlines, allModpathStartingPoints) {
  #Troubleshooting
  nitrateCells <- head(nitrateCells, 320)
  dotCount <- 0
  print("Getting Contributing Point information")
  #End troubleshooting
  
  nitrateCells <- getFlowLinesInNitrateCell(nitrateCells, allModpathFlowlines)

  #for each cell in our nitrate cell data frame
  for (cell in 1:nrow(nitrateCells)) {
    dotCount <- scrDots(dotCount)
    flowlinesInCell <- nitrateCells[["IntersectingFlowlines"]][[cell]]
    
    #initialize helper vectors
    particleRowIndexString <- ""
    landUseString <- ""
    
    #for each flowline in a cell
    for (flowlineIndex in flowlinesInCell) {
      partidloc <- allModpathFlowlines[["conversion_to_partidloc_"]][[flowlineIndex]]
      particleRowIndex <- which(allModpathStartingPoints$partidloc_ == partidloc)
      landUse <- allModpathStartingPoints[["CDL_2022_2"]][[particleRowIndex]]
      particleRowIndexString <- paste(particleRowIndexString, particleRowIndex, sep = " " )
      landUseString <- paste(landUseString, landUse, sep = " ")
    }
    
    particleRowIndexString <- trimws(particleRowIndexString)
    
    
    if (nchar(particleRowIndexString) == 0) {
      particleRowIndexString <- "no particles"
    }
    
    if (nchar(landUseString) == 0) {
      landUseString <- "no land use"
    }
    
    nitrateCells[["ContributingParticleRowIndex"]][[cell]] <- particleRowIndexString
    nitrateCells[["ContributingParticleLandUse"]][[cell]] <- landUseString
  }

  return(nitrateCells)  
}

createLandTypeColumns <- function(nitrateCells) {
  
  nitrateCells <- nitrateCells %>%
    filter(ContributingParticleLandUse != "no land use")
  
  lengthenedNitrateCells <- nitrateCells %>%
    separate_longer_delim(ContributingParticleLandUse, delim = ",") %>%
    mutate(ContributingParticleLandUse = as.numeric(ContributingParticleLandUse))
  
  
  widenedNitrateCells <- lengthenedNitrateCells %>%
    group_by(PLSS, ContributingParticleLandUse) %>%
    tally() %>%
    pivot_wider(names_from = ContributingParticleLandUse, values_from = n, names_prefix = "Land_Use_", values_fill = 0)
  
}


# ----2 Main Callable Tag----
#' main callable tag for determining the correlation between nitrogen levels measured in wells and the land use of contributing zones
mainNitrateCorrelator <- function(){
  # ----2.1 User Input----
  timeFrameOfInterest <- getTimeFrameOfInterest()
  
  # ----2.2 Read in datafiles----
  allModpathFlowlines <- getAllModpathFlowLines()
  allModpathStartingPoints <- st_read(dsn = "P:/Central_Sands_Nitrate_Transport/GIS/ModelOutput/Particles_updated_June2024/1particle_data_top_startpt.shp")
  nitrateCells <- getNitrateCells()
  
  # ----2.3 Find contributing points for our Nitrate Cells----
  nitrateCells <- getContributingPointsInfoForNitrateCells(nitrateCells,timeFrameOfInterest,allModpathFlowlines,allModpathStartingPoints)
  
  # ----2.4 Find the estimated nitrogen impacts given the land use----
  nitrateCells <- createLandTypeColumns(nitrateCells)
  nitrateCellsMLR <- getNitrateCellsMLR(nitrateCells)
  
  # ----2.6 Output to the user----
  #probably just a call to a function that print stuff and makes some plots
  
}