#Project Title: Central Sands Nitrate Correlation - Romano Database and Land Use
#Project Description: evaluates the correlation between the nitrate levels from the romano database, and land use

#TODO
#t02 - look at changing function outputs to just add to the same data frame, rather than making a bunch of data frames
#t03 - this real slow. run profvis to check slowsteps (it's likely my for loops). Also see if t02 would help
#t04 - figure out how to properly use source() so that i can run this from anywhere (VPN or otherwise). I think i'd also need to extend that to anything reading from a file
#t05 - add handling for log(0), which is currently preventing LM from running 
#t06 - make a swap to as.character()

# -------------------Code begins here -----------------------

# ----0 Install Packages and Libraries----
#install.packages('sf')
#install.packages('ggplot2')
#install.packages('raster')
#install.packages('dplyr')
#install.packages('devtools')
#install.packages('profvis')

library(sf)
library(ggplot2)
library(raster)
library(dplyr)
library(tidyr)
library(terra)
#library(devtools)
library(profvis)

source("//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/R_Analysis/Central Sands Nitrate Estimator.R")

# ----1 Define Functions----
#' Read in shapefiles for our cells containing nitrate data
#' Taken from the Romano Database
#' This data will be abbreviated using NTC
#' @returns a dataframe of polygon shapefiles with Nitrate information
getNtcDataSet <- function() {
  ntcDataSet <- st_read(dsn = "//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/R_Analysis/Data Sets/DS002-dataset01/CSGCC_Nitrate_Neonicotinoids.gdb", layer = "Nitrate_stats_per_section_Non_PWS_2017_2022")
  ntcDataSet <- st_transform(ntcDataSet, crs = 3070)
  return(ntcDataSet)
}

#' Given a set of polygons and a set of lines, finds the intersections
#' @param nitrateCells a data frame of polygons with nitrate data
#' @param floDataSet a data frame of lines
#' @returns the nitrateCells data frame with an additional column containing the flowlines that intersect it
getFlowLinesInNitrateCell <- function(nitrateCells, floDataSet) {
  intersections <- st_intersects(nitrateCells, floDataSet)
  nitrateCells$IntersectingFlowlines <- intersections
  return(nitrateCells)
}

#' prints dots to screen while looping
#' For loops take a while in R. This function is to print an output to the screen every once and a while so i know nothing has crashed
#' it prints a dot every 100 iterations, and a number ever thousand iterations
#' @param dotCount a counter variable to keep track of how many times we've gone through our loop
#' @returns a counter to be passed back in to the function
scrDots <- function(dotCount) {
  dotCount <- (dotCount + 1)
  if ((dotCount %% 1000) == 0 ) {
    cat(dotCount %/% 1000)
  }
  else if ((dotCount %% 100) == 0) {
    cat(".")
  }
  return(dotCount)
}

#' Get information about the contributing points for our nitrate cells
#' @param nitrateCells a data from of polygons with nitrate data
#' @param timeFrameOfInterest a time in years
#' @param floDataSet a data frame of flowlines, generated by MODPATH
#' @param stpDataSet a data frame of starting points for the flowlines, generated by MODPATH
getContributingPointsInfoForNitrateCells <- function(nitrateCells, timeFrameOfInterest, floDataSet, stpDataSet) {
  #Troubleshooting
  dotCount <- 0
  print("Getting Contributing Point information")
  #End troubleshooting
  
  nitrateCells <- getFlowLinesInNitrateCell(nitrateCells, floDataSet)
  
  #initialize new columns
  nitrateCells[["ContributingParticleRowIndex"]] <- "pending update"
  nitrateCells[["ContributingParticleLandUse"]] <- "pending update"

  #for each cell in our nitrate cell data frame
  for (cell in 1:nrow(nitrateCells)) {
    dotCount <- scrDots(dotCount)
    flowlinesInCell <- nitrateCells[["IntersectingFlowlines"]][[cell]]
    
    #initialize helper strings
    particleRowIndexString <- ""
    landUseString <- ""
    
    #for each flowline in a cell
    for (flowlineIndex in flowlinesInCell) {
      partidloc <- floDataSet[["conversion_to_partidloc_"]][[flowlineIndex]]
      particleRowIndex <- which(stpDataSet$partidloc_ == partidloc)
      landUse <- stpDataSet[["CDL_2022_2"]][[particleRowIndex]]
      particleRowIndexString <- paste(particleRowIndexString, particleRowIndex, sep = " " )
      landUseString <- paste(landUseString, landUse, sep = " ")
    }
    
    particleRowIndexString <- trimws(particleRowIndexString)
    landUseString <- trimws(landUseString)
    
    
    if (nchar(particleRowIndexString) == 0) {
      particleRowIndexString <- "no particles"
    }
    
    if (nchar(landUseString) == 0) {
      landUseString <- "no land use"
    }
    
    nitrateCells[["ContributingParticleRowIndex"]][[cell]] <- particleRowIndexString
    nitrateCells[["ContributingParticleLandUse"]][[cell]] <- landUseString
  }

  return(nitrateCells)  
}

#' Creates columns for each of the land types and tallies up the contributing zones for each cell
#' Filters out any "no land use" cells, as these are irrelevant to our current endeavor
#' @param nitrateCells a data frame of our nitrate cells
#' @returns a data frame with 1 column per type of land, filled out with counts of how many contributing zones were in that type of land
createLandTypeColumns <- function(nitrateCells) {
  
  nitrateCells <- nitrateCells %>%
    filter(ContributingParticleLandUse != "no land use")
  
  landUseTallyLong <- nitrateCells %>%
    separate_longer_delim(ContributingParticleLandUse, delim = " ") %>%
    mutate(ContributingParticleLandUse = as.numeric(ContributingParticleLandUse)) #TODO t06 - I think switch this to as.character, since these are categories
  
  
  landUseTallyWide <- landUseTallyLong %>%
    group_by(PLSS, ContributingParticleLandUse) %>%
    tally() %>%
    pivot_wider(names_from = ContributingParticleLandUse, values_from = n, names_prefix = "Land_Use_", values_fill = 0)

  nitrateCells <- nitrateCells %>%
    left_join(landUseTallyWide, by = "PLSS")
  
  nitrateCells <- nitrateCells %>%
    mutate(Total_Contrib_Zones = rowSums(across(9:47), na.rm = TRUE)) #This is not robust and will break if columns change sequence.
  
  return(nitrateCells)
}

#' Do a multiple linear regression on variables of interest
#' @param nitrateCells a data frame of our nitrate cells
#' @returns a summary of the regression analysis
getNitrateCellsMLR <- function(nitrateCells) {
  regression <- lm(nitrateCells$MEAN_Nitrate_mg_L_0 ~ nitrateCells$Land_Use_12)
  #regression <- lm(nitrateCells$LogMean ~ nitrateCells$Land_Use_12)
  return(summary(regression))
}

#' Perform some data analysis using WiscLand data set
wisclandAnalysis <- function(nitrateCells, stpDataSet) {
  #look at wiscland data
  wclDataSet <- st_read(dsn = "//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/R_Analysis/Data Sets/DS002-dataset01/CSGCC_Nitrate_Neonicotinoids.gdb", layer = "CSGCC_AG_Wiscland_Bordner_percent_per_section")
  wclDataSet <- st_transform(wclDataSet, 3070)
  dotCount <- 0
  
  nitrateCells[["Wiscland_Area km2"]] <- 0
  nitrateCells[["Wiscland_Ag km2"]] <- 0
  nitrateCells[["Wiscland_Missing_Count"]] <- 0
  
  for (nitrateCell in 1:nrow(nitrateCells)) { 
    dotCount <- scrDots(dotCount)
    contribPartIndexes <- nitrateCells[["ContributingParticleRowIndex"]][[nitrateCell]]
    contribPartIndexesList <- strsplit(contribPartIndexes, " ")[[1]] #turn a delimited string into a list of strings
    contributingParticleList <- stpDataSet[contribPartIndexesList, ]
    
    wisclandStartingCellList <- st_within(contributingParticleList, wclDataSet)
    
    #initialize tallies
    contribZoneArea <- 0
    contribZoneAg <- 0
    contribZoneMissing <- 0
    
    
    for (wisclandStartingCell in wisclandStartingCellList) {
      particleAg <- 0
      particleArea <- 0
      
      #check for scenarios where our particle ID isn't in a wisc land cell
      if (length(wisclandStartingCell) == 0) {
        contribZoneMissing <- (contribZoneMissing + 1)
        next
      }
      
      particleArea <- wclDataSet[["Area_total_km2"]][[wisclandStartingCell]]
      particlePercentAg <- wclDataSet[["Perc_AG_WISCLAND"]][[wisclandStartingCell]] #ztrey left off here. I might need to grab wisclandStargingCell[[1]]. Also, ContribPartIndex is still a vector? Not sure if that's related
      particleAg <- (particlePercentAg/100 * particleArea)
      
      contribZoneArea <- (contribZoneArea + particleArea)
      contribZoneAg <- (contribZoneAg + particleAg)
    }
    
    nitrateCells[["Wiscland_Area km2"]][[nitrateCell]] <- contribZoneArea
    nitrateCells[["Wiscland_Ag km2"]][[nitrateCell]] <- contribZoneAg
    nitrateCells[["Wiscland_Missing_Count"]][[nitrateCell]] <- contribZoneMissing
    
  }
  
  nitrateCells <- nitrateCells %>%
    mutate("Wiscland_Ag_percent" = (`Wiscland_Ag km2`/`Wiscland_Area km2`))
  
  wisclandPlot <- plot(nitrateCells$Wiscland_Ag_percent, log(nitrateCells$MEAN_Nitrate_mg_L_0 + 1)) #add 1 to avoid log(0)
  wisclandPlotSummary <- lm(log(nitrateCells$MEAN_Nitrate_mg_L_0 +1) ~ nitrateCells$Wiscland_Ag_percent) #add 1 to avoid log(0)
  summary(wisclandPlotSummary)
  return(summary(wisclandPlotSummary))
}

#' Read in our land cover data set from a raster file
#' Objects from this data set will be abbreviated as LND objects
#' @returns a raster data set
getLndDataSet <- function() {
  lndDataSet <- rast("//ad.wisc.edu/wgnhs/GIS_Library/library/State/Landcover/wiscland2/wiscland2_dataset/level3/wiscland2_level3.tif")
  return(lndDataSet)
}

#' Analyzes the impact of a given nitrate cell's land use on it's nitrate levels
#' @param ntcDataSet a dataframe of nitrate cell polygons
#' @param lndSet a SpatRaster of land cover
cellLandUseAnalysis <- function(ntcSet, lndSet) {
  #Make sure our CRSs match
  ntcSet <- st_transform(ntcSet, crs(lndSet))
  
  ntcCount <- nrow(ntcSet)
  landCoverFractions <- matrix(0, nrow = ntcCount, ncol = 16) #TODO - have this pull dynamically as a count from levels(lndSet) 
  
  #Get to work counting
  for (ntcIndex in 1:ntcCount) {
    ntcID <- st_geometry(ntcSet[ntcIndex, ])
    croppedLandCover <- crop(lndSet, ntcID) #crop the land cover raster to the extent of the polygon for performance
    maskedLandCover <- mask(croppedLandCover, vect(ntcID)) #get the raster cells inside the polygon
    landCoverCounts <- freq(maskedLandCover, useNA = "No")
    totalCells <- sum(landCoverCounts$count)
    
    for (landCoverType in landCoverCounts$value) {
      landCoverFractions[ntcIndex, landCoverType] <- landCoverCounts$count[landCoverCounts$value == landCoverType] / totalCells
    }
  }
  
}

#'Just a tag to keep my experimental and testing plots
dataExplorer <- function(nitrateCells) {
  hist(nitrateCells$Land_Use_1)
  with(nitrateCells, hist(log(Land_Use_1)))
  
  plot(nitrateCells$Land_Use_1, log(nitrateCells$MEAN_Nitrate_mg_L_0))
  regression <- lm(nitrateCells$LogMean ~ nitrateCells$Land_Use_1)
  summary(regression)
  
  #looking at number of contributing zones per cell
  fewerNitrateCells <- nitrateCells %>%
    filter(sapply(ContributingParticleLandUse, nchar) < 50)
}

# ----2 Main Callable Tag----
#' main callable tag for determining the correlation between nitrogen levels measured in wells and the land use of contributing zones
mainNitrateCorrelator <- function(){
  # ----2.1 User Input----
  timeFrameOfInterest <- getTimeFrameOfInterest()
  
  # ----2.2 Read in datafiles----
  floDataSet <- getFloDataSet() #change to floDataSet
  stpDataSet <- getStpDataSet()
  lndDataSet <- getLndDataSet()
  ntcDataSet <- getNtcDataSet()
  ntcSampleSet <- slice_sample(ntcDataSet, n = 500)
  
  # ----2.2.5 Analyze the cell's land use on nitrate levels----
  cellLandUseRegression <- cellLandUseAnalysis(ntcSampleSet, lndDataSet)
  
  # ----2.3 Find contributing points for our Nitrate Cells----
  ntcSampleSet <- getContributingPointsInfoForNitrateCells(ntcSampleSet,timeFrameOfInterest,floDataSet,stpDataSet)
  
  # ----2.4 Find the estimated nitrogen impacts given the land use----
  ntcSampleSet <- createLandTypeColumns(ntcSampleSet)
  
  # ----2.6 Output to the user----
  #probably just a call to a function that print stuff and makes some plots
  
  #Summary from WiscLand data set
  wisclandSummary <- wisclandAnalysis(ntcSampleSet, stpDataSet)
  
  
  #Summary for selected land use
  ntcSampleSet <- ntcSampleSet %>%
    mutate(LogMean = if_else(MEAN_Nitrate_mg_L_0 != 0, log(MEAN_Nitrate_mg_L_0), 0))
  
  ntcSampleSet <- ntcSampleSet %>%
    mutate(percentCorn = (Land_Use_1/Total_Contrib_Zones), percentSweetCorn=(Land_Use_12/Total_Contrib_Zones), percentPotato = (Land_Use_43/Total_Contrib_Zones))

  nitratePlot <- plot((ntcSampleSet$percentPotato + ntcSampleSet$percentCorn + ntcSampleSet$percentSweetCorn), ntcSampleSet$MEAN_Nitrate_mg_L_0,
                      xlab = "Fraction of High Ag Contributing Zones (Corn + Sweet Corn + Potato)",
                      ylab = "Mean Nitrate (mg/L)",
                      main = "Nitrate vs. Land Use in Contributing Zones")
  nitrateRegression <- lm((ntcSampleSet$MEAN_Nitrate_mg_L_0) ~ ntcSampleSet$percentPotato + ntcSampleSet$percentCorn + ntcSampleSet$percentSweetCorn)
  summary(nitrateRegression)
  print(nitratePlot)
  nitrateCellsMLR <- getNitrateCellsMLR(ntcSampleSet)
  print(nitrateCellsMLR)
  
  # ----2.6.1 tag for exploratory Data Analysis----
  dataExplorer(ntcSampleSet)
  
}