#Project Title: Central Sands Nitrate Correlation - Romano Database and Land Use
#Project Description: evaluates the correlation between the nitrate levels from the romano database, and land use

#TODO
#t02 - look at changing function outputs to just add to the same data frame, rather than making a bunch of data frames

# -------------------Code begins here -----------------------

# ----0 Install Packages and Libraries----
#install.packages('sf')
#install.packages('ggplot2')
#install.packages('raster')
#install.packages('dplyr')
#install.packages('devtools')
#install.packages('profvis')

library(sf)
library(ggplot2)
library(raster)
library(dplyr)
library(tidyr)
library(terra)
#library(devtools)
library(profvis)

source("Central Sands Nitrate Estimator.R")

# ----1 Define Functions----
#' Read in shapefiles for our cells containing nitrate data
#' Taken from the Romano Database
#' This data will be abbreviated using NTC
#' @returns a dataframe of polygon shapefiles with Nitrate information
getNtcDataSet <- function() {
  ntcDataSet <- st_read(dsn = "//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/R_Analysis/Data Sets/DS002-dataset01/CSGCC_Nitrate_Neonicotinoids.gdb", layer = "Nitrate_stats_per_section_Non_PWS_2017_2022")
  ntcDataSet <- st_transform(ntcDataSet, crs = 3070)
  return(ntcDataSet)
}

#' Given a set of polygons and a set of lines, finds the intersections
#' @param ntcSet a data frame of polygons with nitrate data
#' @param floDataSet a data frame of lines
#' @returns the ntcSet data frame with an additional column containing the flowlines that intersect it
getFlowLinesInNitrateCell <- function(ntcSet, floDataSet) {
  intersections <- st_intersects(ntcSet, floDataSet)
  ntcSet$IntersectingFlowlines <- intersections
  return(ntcSet)
}

#' prints dots to screen while looping
#' For loops take a while in R. This function is to print an output to the screen every once and a while so i know nothing has crashed
#' it prints a dot every 100 iterations, and a number ever thousand iterations
#' @param dotCount a counter variable to keep track of how many times we've gone through our loop
#' @returns a counter to be passed back in to the function
scrDots <- function(dotCount) {
  dotCount <- (dotCount + 1)
  if ((dotCount %% 1000) == 0 ) {
    cat(dotCount %/% 1000)
  }
  else if ((dotCount %% 100) == 0) {
    cat(".")
  }
  return(dotCount)
}

#' Get information about the contributing points for our nitrate cells
#' @param ntcSet a data from of polygons with nitrate data
#' @param timeFrameOfInterest a time in years
#' @param floSet a data frame of flowlines, generated by MODPATH
#' @param stpSet a data frame of starting points for the flowlines, generated by MODPATH
getContributingPointsInfoForNitrateCells <- function(ntcSet, timeFrameOfInterest, floSet, stpSet) {
  #Troubleshooting
  dotCount <- 0
  print("Getting Contributing Point information")
  #End troubleshooting
  
  ntcSet <- getFlowLinesInNitrateCell(ntcSet, floSet)
  
  #initialize new columns
  ntcSet[["ContributingParticleRowIndex"]] <- "pending update"
  ntcSet[["ContributingParticleLandUse"]] <- "pending update"

  #for each cell in our nitrate cell data frame
  for (cell in 1:nrow(ntcSet)) {
    dotCount <- scrDots(dotCount)
    flowlinesInCell <- ntcSet[["IntersectingFlowlines"]][[cell]]
    
    #initialize helper strings
    particleRowIndexString <- ""
    landUseString <- ""
    
    #for each flowline in a cell
    for (flowlineIndex in flowlinesInCell) {
      partidloc <- floSet[["conversion_to_partidloc_"]][[flowlineIndex]]
      particleRowIndex <- which(stpSet$partidloc_ == partidloc)
      landUse <- stpSet[["CDL_2022_2"]][[particleRowIndex]]
      particleRowIndexString <- paste(particleRowIndexString, particleRowIndex, sep = " " )
      landUseString <- paste(landUseString, landUse, sep = " ")
    }
    
    particleRowIndexString <- trimws(particleRowIndexString)
    landUseString <- trimws(landUseString)
    
    
    if (nchar(particleRowIndexString) == 0) {
      particleRowIndexString <- "no particles"
    }
    
    if (nchar(landUseString) == 0) {
      landUseString <- "no land use"
    }
    
    ntcSet[["ContributingParticleRowIndex"]][[cell]] <- particleRowIndexString
    ntcSet[["ContributingParticleLandUse"]][[cell]] <- landUseString
  }

  return(ntcSet)  
}

#' Creates columns for each of the land types and tallies up the contributing zones for each cell
#' Filters out any "no land use" cells, as these are irrelevant to our current endeavor
#' @param ntcSet a data frame of our nitrate cells
#' @returns a data frame with 1 column per type of land, filled out with counts of how many contributing zones were in that type of land
createLandTypeColumns <- function(ntcSet) {
  #Remove Cells without contributing zone land uses
  ntcSet <- ntcSet %>%
    filter(ContributingParticleLandUse != "no land use")
  
  #Constants
  colNamePrefix <- "CZ_Land_Cover_"
  
  #Split my space-delimited column into individual rows for each land cover value
  landUseTallyLong <- ntcSet %>%
    separate_longer_delim(ContributingParticleLandUse, delim = " ") %>%
    mutate(ContributingParticleLandUse = as.character(ContributingParticleLandUse))
  
  #Tally up counts of each land cover, turn them into columns, and collapse our rows
  landUseTallyWide <- landUseTallyLong %>%
    group_by(PLSS, ContributingParticleLandUse) %>%
    tally() %>%
    pivot_wider(names_from = ContributingParticleLandUse, values_from = n, names_prefix = colNamePrefix, values_fill = 0)

  #Merge our talied up land use counts back into our original data set
  ntcSet <- ntcSet %>%
    left_join(landUseTallyWide, by = "PLSS")
  
  #Add a column that tallies the land cover count for the row
  ntcSet <- ntcSet %>%
    mutate(Total_CZ_Land_Cover = rowSums(across(starts_with(colNamePrefix)), na.rm = TRUE))

  return(ntcSet)
}

#' NEEDS REPAIR - Perform some analysis on contributing zone particles using the wiscland data from the Romano Data set
#' This is now defunct, as we're just grabbing the wiscland data from the primary source and analyzing that
#' 
#' 
#' If this is to be used for meaningful analysis, it'll need to be updated to take the LND data set as the wiscland source of truth,
#' rather than loading in a separate WCL dataset
#' 
#' @param ntcSet a data frame of NTCs
#' @param stpSet a data frame of STPs
#' 
wisclandAnalysis <- function(ntcSet, stpSet) {
  #look at wiscland data
  wclDataSet <- st_read(dsn = "//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/R_Analysis/Data Sets/DS002-dataset01/CSGCC_Nitrate_Neonicotinoids.gdb", layer = "CSGCC_AG_Wiscland_Bordner_percent_per_section")
  wclDataSet <- st_transform(wclDataSet, 3070)
  dotCount <- 0
  
  ntcSet[["Wiscland_CZ_Area_km2"]] <- 0 #the total area from all of the contributing zones
  ntcSet[["Wiscland_CZ_Ag_km2"]] <- 0 #the area from all of the contributing zones that's agricultural land
  ntcSet[["Wiscland_CZ_Missing_Count"]] <- 0 #the count of scenarios where our starting point isn't in a wiscland cell. We won't be able to factor the land cover for these points into our fractions, so we'll just keep track of how many there are.
  
  for (nitrateCell in 1:nrow(ntcSet)) { 
    dotCount <- scrDots(dotCount)
    contribPartIndexes <- ntcSet[["ContributingParticleRowIndex"]][[nitrateCell]]
    contribPartIndexesList <- strsplit(contribPartIndexes, " ")[[1]] #turn a delimited string into a list of strings
    contributingParticleList <- stpSet[contribPartIndexesList, ]
    
    wisclandStartingCellList <- st_within(contributingParticleList, wclDataSet)
    
    #initialize tallies
    contribZoneArea <- 0
    contribZoneAg <- 0
    contribZoneMissing <- 0
    
    
    for (wisclandStartingCell in wisclandStartingCellList) {
      particleAg <- 0
      particleArea <- 0
      
      #check for scenarios where our particle ID isn't in a wisc land cell
      if (length(wisclandStartingCell) == 0) {
        contribZoneMissing <- (contribZoneMissing + 1)
        next
      }
      
      particleArea <- wclDataSet[["Area_total_km2"]][[wisclandStartingCell]]
      particlePercentAg <- wclDataSet[["Perc_AG_WISCLAND"]][[wisclandStartingCell]]
      particleAg <- (particlePercentAg/100 * particleArea)
      
      contribZoneArea <- (contribZoneArea + particleArea)
      contribZoneAg <- (contribZoneAg + particleAg)
    }
    
    ntcSet[["Wiscland_CZ_Area_km2"]][[nitrateCell]] <- contribZoneArea
    ntcSet[["Wiscland_CZ_Ag_km2"]][[nitrateCell]] <- contribZoneAg
    ntcSet[["Wiscland_CZ_Missing_Count"]][[nitrateCell]] <- contribZoneMissing
    
  }
  
  ntcSet <- ntcSet %>%
    mutate("Wiscland_CZ_Ag_percent" = (`Wiscland_CZ_Ag_km2`/`Wiscland_CZ_Area_km2`))
  
  wisclandPlot <- plot(ntcSet$Wiscland_CZ_Ag_percent, log(ntcSet$MEAN_Nitrate_mg_L_0 + 1)) #add 1 to avoid log(0)
  wisclandPlotSummary <- lm(log(ntcSet$MEAN_Nitrate_mg_L_0 +1) ~ ntcSet$Wiscland_CZ_Ag_percent) #add 1 to avoid log(0)
  summary(wisclandPlotSummary)
  return(summary(wisclandPlotSummary))
}

#' Read in our land cover data set from a raster file
#' Objects from this data set will be abbreviated as LND objects
#' @returns a raster data set
getLndDataSet <- function() {
  lndDataSet <- rast("//ad.wisc.edu/wgnhs/GIS_Library/library/State/Landcover/wiscland2/wiscland2_dataset/level3/wiscland2_level3.tif") #WISCLAND
  #lndDataSet <- rast("//ad.wisc.edu/wgnhs/Projects/Central_Sands_Nitrate_Transport/GIS/CropScapeData/CDL_2022_20231127143930_554525100.tif")
  lndDataSet <- project(lndDataSet, "EPSG:3070")
  return(lndDataSet)
}

#' Given a set of polygons and a raster, finds the count of the raster categories in each polygon
#' @param ntcSet a dataframe of nitrate cell polygons
#' @param lndSet a SpatRaster of land cover
#' @param activeRasterCat the active category to use for our raster. Use 7 for WISCLAND2-Level3; use 4 for CropScape
#' @returns the ntcSet dataframe with information about how it overlays with the lndSet raster
mergeLNDInfo <- function(ntcSet, lndSet, activeRasterCat) {
  #Make sure our CRSs match
  ntcSet <- st_transform(ntcSet, crs(lndSet))
  
  #Constants and Initialize
  colPrefix <- "NTC_Land_Cover_"
  ntcCount <- nrow(ntcSet)
  totalCellsTracker <- numeric(ntcCount)
  dotCount <- 0
  
  #Create a matrix to keep track of our counts
  activeCat(lndSet) <- activeRasterCat
  activeCatName <- names(lndSet)
  lndCategories <- levels(lndSet)
  lndCatNames <- unlist(lapply(lndCategories, function(x) x[[activeCatName]]))
  lndCatNames <- paste0(colPrefix,lndCatNames)
  lndCatNameCount <- length(lndCatNames) #determine our number of columns
  lndCatCounts <- matrix(0, nrow = ntcCount, ncol = lndCatNameCount, dimnames = list(NULL, lndCatNames)) #create a matrix to store the count of each land category for each NTC
  
  
  #Get to work counting
  for (ntcIndex in 1:ntcCount) {
    dotCount <- scrDots(dotCount)
    ntcID <- st_geometry(ntcSet[ntcIndex, ])
    croppedLandCover <- crop(lndSet, ntcID) #crop the land cover raster to the extent of the polygon for performance
    maskedLandCover <- mask(croppedLandCover, vect(ntcID)) #get the raster cells inside the polygon
    landCoverCounts <- freq(maskedLandCover)
    totalCells <- sum(landCoverCounts$count)
    
    #store total cells so we can add them back in later
    totalCellsTracker[ntcIndex] <- totalCells
    
    #Get the count of cells for each category
    for (lndCat in landCoverCounts$value) {
      lndColName <- paste0(colPrefix, lndCat)
      lndCatCount <- landCoverCounts$count[landCoverCounts$value == lndCat]
      lndCatCounts[ntcIndex, lndColName] <- (lndCatCount)
    }
  }
  
  lndCatCounts <- cbind(lndCatCounts, Total_NTC_Land_Cover = totalCellsTracker)
  
  #convert matrix to data frame, bind it to our NTC info, and return
  lndCatCounts <- as.data.frame(lndCatCounts)
  ntcSet <- cbind(ntcSet, lndCatCounts)
  return(ntcSet)    
}

#'Given an NTC Set, creates a new column that sums up the columns passed in. This will be used to help
#'group and simplify our analysis later on
#' @param ntcSet a dataframe of NTCs. Assumes that land use columns are in absolute area, not relative fractions
#' @param columnNames a list of column names that we'd like to sum
#' @param sumColumnName the name to give the new column being created
#' @returns a a dataframe with a single column which is the summed amounts from the columns
createSumColumn <- function(ntcSet,columnNames,sumColumnName) {
  ntcSet <- ntcSet %>%
    mutate(!!sumColumnName := rowSums(across(all_of(columnNames)), na.rm = TRUE)) #the !! and := allow me to use the string stored in sumColumnName to name the column
  return(ntcSet)
}


#' A tag to house different plots and graphs
#' @param ntcSet a dataframe with nitrate info to analyze
dataExplorer <- function(ntcSet) {
  #1---Data Plots----
  hist(ntcSet$MEDIAN_Nitrate_mg_L_0)
  with(ntcSet, hist(log10(MEDIAN_Nitrate_mg_L_0 + 0.01)))
  
  #print some stuff on a map to help me out
  ggplot(data = ntcSet) +
    geom_sf(aes(fill = `MEAN_Nitrate_mg_L_0`)) +
    scale_fill_viridis_c() +
    theme_minimal() +
    labs(fill = "Nitrate Levels")
  
  #Let's get frequency counts of stuff
  ntcNoGeom <- st_drop_geometry(ntcSet)
  
  #2----Data Manipulations for Analysis
  plot(ntcNoGeom$Total_NTC_Land_Cover)
  
  #3----Linear Regression for Nitrate Cell Land Cover----
  #Nitrate Adders
  ntcNitrateAdderColumns <- c("NTC_Land_Cover_Potato.Vegetable",
                              "NTC_Land_Cover_Continuous.Corn")
  ntcNitrateAdderSumColumnName <- "NTC_Nitrate_Adders"
  ntcNoGeom <- createSumColumn(ntcNoGeom, ntcNitrateAdderColumns, ntcNitrateAdderSumColumnName)
  
  #Nitrate Removers
  ntcNitrateRemoverColumns <- c("NTC_Land_Cover_Oak", 
                                "NTC_Land_Cover_Pine",
                                "NTC_Land_Cover_Aspen.Paper.Birch.Forest",
                                "NTC_Land_Cover_Fir.Spruce",
                                "NTC_Land_Cover_Red.Maple",
                                "NTC_Land_Cover_Northern.Hardwoods",
                                "NTC_Land_Cover_Mixed.Deciduous.Coniferous.Forest",
                                "NTC_Land_Cover_Hemlock.Hardwoods",
                                "NTC_Land_Cover_Central.Hardwoods",
                                "NTC_Land_Cover_Broad.leaved.Deciduous.Wetland.Shrub",
                                "NTC_Land_Cover_Broad.leaved.Evergreen.Wetland.Shrub",
                                "NTC_Land_Cover_Mixed.Deciduous.Coniferous.Forested.Wetland",
                                "NTC_Land_Cover_Coniferous.Forested.Wetland",
                                "NTC_Land_Cover_Needle.leaved.Wetland.Shrub",
                                "NTC_Land_Cover_Aspen.Forested.Wetland")
  ntcNitrateRemoverSumColumnName <- "NTC_Nitrate_Removers"
  ntcNoGeom <- createSumColumn(ntcNoGeom, ntcNitrateRemoverColumns, ntcNitrateRemoverSumColumnName)
  
  ntcModel <- lm(ntcNoGeom$MEAN_Nitrate_mg_L_0 ~ ntcNoGeom$NTC_Nitrate_Adders + ntcNoGeom$NTC_Nitrate_Removers)
  summary(ntcModel)
  ntcResiduals <- residuals(ntcModel)
  
  plot(fitted(ntcModel), ntcResiduals,
       xlab = "Prediction", ylab = "Residuals",
       main = "Residuals vs. Predicted - Cell")
  abline(h = 0, col = "red")

  #Linear Regression for Contributing Zones Land Cover
  #Nitrate Adders
  czNitrateAdderColumns <- c("CZ_Land_Cover_1",
                           "CZ_Land_Cover_43",
                           "CZ_Land_Cover_12")
  czNitrateAdderSumColumnName <- "CZ_Nitrate_Adders"
  ntcNoGeom <- createSumColumn(ntcNoGeom, czNitrateAdderColumns, czNitrateAdderSumColumnName)
  
  #Nitrate Removers
  czNitrateRemoverColumns <- c("CZ_Land_Cover_141",
                               "CZ_Land_Cover_142",
                               "CZ_Land_Cover_143",
                               "CZ_Land_Cover_190",
                               "CZ_Land_Cover_195")
  czNitrateRemoverSumColumnName <- "CZ_Nitrate_Removers"
  ntcNoGeom <- createSumColumn(ntcNoGeom, czNitrateRemoverColumns, czNitrateRemoverSumColumnName)

  
  czRegression <- lm(ntcNoGeom$MEAN_Nitrate_mg_L_0 ~ ntcNoGeom$CZ_Nitrate_Adders + ntcNoGeom$CZ_Nitrate_Removers)
  summary(czRegression)
  czResiduals <- residuals(czRegression)
  
  plot(fitted(czRegression), czResiduals,
       xlab = "Prediction", ylab = "Residuals",
       main = "Residuals vs. Predicted - Contrib Zone")
  abline(h = 0, col = "red")
  
  #Combined
  #Nitrate Adders
  combinedNitrateAdderColumns <- c("NTC_Land_Cover_Potato.Vegetable",
                           "NTC_Land_Cover_Continuous.Corn",
                           "NTC_Land_Cover_Dairy.Rotation",
                           "CZ_Land_Cover_1",
                           "CZ_Land_Cover_43",
                           "CZ_Land_Cover_12")
  combinedNitrateAdderSumColumnName <- "Combined_Nitrate_Adders"
  ntcNoGeom <- createSumColumn(ntcNoGeom, combinedNitrateAdderColumns, combinedNitrateAdderSumColumnName)
  
  #Nitrate Removers
  combinedNitrateRemoverColumns <- c("NTC_Land_Cover_Oak", 
                                "NTC_Land_Cover_Pine",
                                "NTC_Land_Cover_Aspen.Paper.Birch.Forest",
                                "NTC_Land_Cover_Fir.Spruce",
                                "NTC_Land_Cover_Red.Maple",
                                "NTC_Land_Cover_Northern.Hardwoods",
                                "NTC_Land_Cover_Mixed.Deciduous.Coniferous.Forest",
                                "NTC_Land_Cover_Hemlock.Hardwoods",
                                "NTC_Land_Cover_Central.Hardwoods",
                                "NTC_Land_Cover_Broad.leaved.Deciduous.Wetland.Shrub",
                                "NTC_Land_Cover_Broad.leaved.Evergreen.Wetland.Shrub",
                                "NTC_Land_Cover_Mixed.Deciduous.Coniferous.Forested.Wetland",
                                "NTC_Land_Cover_Coniferous.Forested.Wetland",
                                "NTC_Land_Cover_Needle.leaved.Wetland.Shrub",
                                "NTC_Land_Cover_Aspen.Forested.Wetland",
                                "NTC_Land_Cover_Cash.Grain",
                                "CZ_Land_Cover_141",
                                "CZ_Land_Cover_142",
                                "CZ_Land_Cover_143",
                                "CZ_Land_Cover_190",
                                "CZ_Land_Cover_195")
  combinedNitrateRemoverSumColumnName <- "Combined_Nitrate_Removers"
  ntcNoGeom <- createSumColumn(ntcNoGeom, combinedNitrateRemoverColumns, combinedNitrateRemoverSumColumnName)
  combinedRegression <- lm(ntcNoGeom$MEAN_Nitrate_mg_L_0 ~ ntcNoGeom$Combined_Nitrate_Adders + ntcNoGeom$Combined_Nitrate_Removers)
  summary(combinedRegression)
  combinedResiduals <- residuals(combinedRegression)
  plot(fitted(combinedRegression), combinedResiduals,
       xlab = "Prediction", ylab = "Residuals",
       main = "Residuals vs. Predicted - Combined")
  abline(h = 0, col = "red")
  
}

# ----2 Main Callable Tag----
#' main callable tag for determining the correlation between nitrogen levels measured in wells and the land use of contributing zones
mainNitrateCorrelator <- function(){
  # ----2.1 User Input----
  timeFrameOfInterest <- getTimeFrameOfInterest()
  
  # ----2.2 Read in datafiles----
  floDataSet <- getFloDataSet()
  stpDataSet <- getStpDataSet()
  lndDataSet <- getLndDataSet()
  activeRasterCat <- 7
  ntcDataSet <- getNtcDataSet()
  set.seed(19058) #control our slice sample call for reproducibility
  #ntcSampleSet <- slice_sample(ntcDataSet, n = 500)
  ntcSampleSet <- ntcDataSet
  
  # ----2.2.5 Analyze the cell's land use on nitrate levels----
  ntcSampleSet <- mergeLNDInfo(ntcSampleSet, lndDataSet, activeRasterCat)
  
  # ----2.3 Find contributing points for our Nitrate Cells----
  ntcSampleSet <- getContributingPointsInfoForNitrateCells(ntcSampleSet,timeFrameOfInterest,floDataSet,stpDataSet)
  
  # ----2.4 Find the estimated nitrogen impacts given the land use----
  ntcSampleSet <- createLandTypeColumns(ntcSampleSet)
  
  # ----2.6 Output to the user----
  #probably just a call to a function that print stuff and makes some plots
  
  #Summary from Romano's WiscLand data
  wisclandSummary <- wisclandAnalysis(ntcSampleSet, stpDataSet)
  

  # ----2.6.1 tag for exploratory Data Analysis----
  dataExplorer(ntcSampleSet)
  
  # ----2.6.2 Summary for selected land use----

  
}